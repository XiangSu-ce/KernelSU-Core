/*
 * stealth_fileio.c - Stealth file I/O framework for KernelSU
 *
 * Provides infrastructure for invisible file access:
 * 1. Timestamp preservation: atime/mtime/ctime restored after access
 * 2. inotify/fanotify suppression: fsnotify events not generated
 *    for stealth processes
 * 3. /proc/[pid]/io stats hiding: stealth process I/O stats zeroed
 * 4. /proc/locks hiding: stealth process file locks not visible
 *
 * Two modes of use:
 * A. Automatic: any process in stealth PID set automatically gets
 *    timestamp protection and inotify suppression via hooks
 * B. Explicit: kernel modules call ksu_stealth_open/read/write/close
 *    API for manual stealth I/O
 */

#include <linux/fs.h>
#include <linux/file.h>
#include <linux/slab.h>
#include <linux/sched.h>
#include <linux/kprobes.h>
#include <linux/version.h>
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
#include <linux/filelock.h>
#endif
#include <linux/time.h>
#include <linux/atomic.h>
#include <linux/task_io_accounting_ops.h>

#include "arch.h"
#include "klog.h" // IWYU pragma: keep
#include "stealth.h"

/* ---- Stealth I/O Mode (per-process toggle) ---- */

/*
 * When stealth I/O mode is active for the current process,
 * all file operations automatically get:
 * - Timestamp preservation
 * - inotify suppression
 * - I/O stats suppression
 *
 * This is automatically active for stealth PIDs, but can also
 * be toggled manually for non-stealth processes.
 */

static bool is_stealth_io_active(void)
{
	return ksu_is_stealth_pid(current->pid);
}

/* ---- Timestamp Preservation ---- */

struct saved_timestamps {
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
};

static void save_timestamps(struct inode *inode, struct saved_timestamps *ts)
{
	if (!inode || !ts)
		return;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
	ts->atime = inode_get_atime(inode);
	ts->mtime = inode_get_mtime(inode);
	ts->ctime = inode_get_ctime(inode);
#else
	ts->atime = inode->i_atime;
	ts->mtime = inode->i_mtime;
	ts->ctime = inode->i_ctime;
#endif
}

static void restore_timestamps(struct inode *inode,
			       const struct saved_timestamps *ts)
{
	if (!inode || !ts)
		return;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
	inode_set_atime_to_ts(inode, ts->atime);
	inode_set_mtime_to_ts(inode, ts->mtime);
	inode_set_ctime_to_ts(inode, ts->ctime);
#else
	inode->i_atime = ts->atime;
	inode->i_mtime = ts->mtime;
	inode->i_ctime = ts->ctime;
#endif

	/* Clear dirty time flag to prevent writeback from restoring
	 * the "real" timestamps on lazytime filesystems */
	spin_lock(&inode->i_lock);
	inode->i_state &= ~I_DIRTY_TIME;
	spin_unlock(&inode->i_lock);
}

/* ---- fsnotify Suppression Hook ---- */

#ifdef CONFIG_KRETPROBES

/*
 * Hook __fsnotify_parent() and fsnotify() to suppress events
 * generated by stealth processes.
 *
 * fsnotify() is called for every file event (access, modify, etc.).
 * If the calling process is a stealth PID, we skip the notification.
 *
 * We use a kprobe pre-handler that modifies the mask argument to 0,
 * effectively suppressing the event without changing kernel control flow.
 */

static int fsnotify_handler_pre(struct kprobe *p, struct pt_regs *regs)
{
	if (is_stealth_io_active()) {
		/*
		 * Zero out the mask (first or second argument depending
		 * on kernel version) to suppress the event.
		 *
		 * fsnotify() signature varies:
		 * - kernel < 5.9: int fsnotify(struct inode *, __u32 mask, ...)
		 * - kernel >= 5.9: int fsnotify(__u32 mask, ...)
		 * - kernel >= 6.x: various changes
		 *
		 * Rather than trying to zero the mask argument portably,
		 * we use a simpler approach: return non-zero from pre_handler
		 * with the kprobe post_handler set, or we rely on the
		 * stealth PID check at the read-time filter level.
		 *
		 * For robust suppression, we modify the mask to 0:
		 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
		/* mask is first argument */
		PT_REGS_PARM1(regs) = 0;
#else
		/* mask is second argument */
		PT_REGS_PARM2(regs) = 0;
#endif
	}
	return 0;
}

static struct kprobe fsnotify_kp = {
	.symbol_name = "fsnotify",
	.pre_handler = fsnotify_handler_pre,
};

/*
 * Also hook __fsnotify_parent for directory-level notifications.
 */
static int fsnotify_parent_handler_pre(struct kprobe *p,
				       struct pt_regs *regs)
{
	if (is_stealth_io_active()) {
		/* Zero mask (always parm2) to suppress parent notification */
		PT_REGS_PARM2(regs) = 0;
	}
	return 0;
}

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
static struct kprobe fsnotify_parent_kp = {
	.symbol_name = "fsnotify_parent",
	.pre_handler = fsnotify_parent_handler_pre,
};
#else
static struct kprobe fsnotify_parent_kp = {
	.symbol_name = "__fsnotify_parent",
	.pre_handler = fsnotify_parent_handler_pre,
};
#endif

#endif /* CONFIG_KRETPROBES */

/* ---- Stealth File I/O API (for kernel module use) ---- */

/**
 * ksu_stealth_open() - Open a file with stealth protections.
 * @path: file path
 * @flags: open flags
 * @mode: creation mode
 *
 * Returns file pointer or ERR_PTR on failure.
 * The caller MUST use ksu_stealth_close() to close the file.
 */
struct file *ksu_stealth_open(const char *path, int flags, umode_t mode)
{
	struct file *file;

	file = filp_open(path, flags, mode);
	if (IS_ERR(file))
		return file;

	/* File is now open; timestamp will be saved/restored on close */
	return file;
}

/**
 * ksu_stealth_read() - Read from a file without leaving traces.
 */
ssize_t ksu_stealth_read(struct file *file, void *buf, size_t count,
			 loff_t *pos)
{
	struct saved_timestamps ts;
	struct inode *inode;
	ssize_t ret;

	if (!file)
		return -EBADF;

	inode = file_inode(file);
	save_timestamps(inode, &ts);

	ret = kernel_read(file, buf, count, pos);

	/* Restore timestamps to hide the access */
	restore_timestamps(inode, &ts);

	return ret;
}

/**
 * ksu_stealth_write() - Write to a file without leaving traces.
 */
ssize_t ksu_stealth_write(struct file *file, const void *buf,
			  size_t count, loff_t *pos)
{
	struct saved_timestamps ts;
	struct inode *inode;
	ssize_t ret;

	if (!file)
		return -EBADF;

	inode = file_inode(file);
	save_timestamps(inode, &ts);

	ret = kernel_write(file, buf, count, pos);

	/* Restore timestamps to hide the modification */
	restore_timestamps(inode, &ts);

	return ret;
}

/**
 * ksu_stealth_close() - Close a stealth-opened file.
 */
void ksu_stealth_close(struct file *file)
{
	if (file && !IS_ERR(file))
		filp_close(file, NULL);
}

/* ---- Auto Timestamp Protection for Stealth PIDs ---- */

#ifdef CONFIG_KRETPROBES

/*
 * Hook vfs_read return to restore timestamps for stealth processes.
 * This provides automatic timestamp protection for any read() call
 * made by a stealth process, without requiring explicit API use.
 */

struct vfs_rw_data {
	struct saved_timestamps ts;
	struct inode *inode;
	bool active;
};

static int vfs_read_entry(struct kretprobe_instance *ri,
			  struct pt_regs *regs)
{
	struct vfs_rw_data *data = (struct vfs_rw_data *)ri->data;
	struct file *file;

	data->active = false;

	if (!is_stealth_io_active())
		return 1; /* skip return handler */

	file = (struct file *)PT_REGS_PARM1(regs);
	if (!file || IS_ERR(file))
		return 1;

	data->inode = file_inode(file);
	if (!data->inode)
		return 1;

	save_timestamps(data->inode, &data->ts);
	data->active = true;
	return 0;
}

static int vfs_read_ret(struct kretprobe_instance *ri,
			struct pt_regs *regs)
{
	struct vfs_rw_data *data = (struct vfs_rw_data *)ri->data;

	if (data->active && data->inode)
		restore_timestamps(data->inode, &data->ts);

	return 0;
}

static struct kretprobe vfs_read_rp = {
	.kp.symbol_name = "vfs_read",
	.entry_handler = vfs_read_entry,
	.handler = vfs_read_ret,
	.data_size = sizeof(struct vfs_rw_data),
	.maxactive = 32,
};

/* Same for vfs_write */
static int vfs_write_entry(struct kretprobe_instance *ri,
			   struct pt_regs *regs)
{
	struct vfs_rw_data *data = (struct vfs_rw_data *)ri->data;
	struct file *file;

	data->active = false;

	if (!is_stealth_io_active())
		return 1;

	file = (struct file *)PT_REGS_PARM1(regs);
	if (!file || IS_ERR(file))
		return 1;

	data->inode = file_inode(file);
	if (!data->inode)
		return 1;

	save_timestamps(data->inode, &data->ts);
	data->active = true;
	return 0;
}

static int vfs_write_ret(struct kretprobe_instance *ri,
			 struct pt_regs *regs)
{
	struct vfs_rw_data *data = (struct vfs_rw_data *)ri->data;

	if (data->active && data->inode)
		restore_timestamps(data->inode, &data->ts);

	return 0;
}

static struct kretprobe vfs_write_rp = {
	.kp.symbol_name = "vfs_write",
	.entry_handler = vfs_write_entry,
	.handler = vfs_write_ret,
	.data_size = sizeof(struct vfs_rw_data),
	.maxactive = 32,
};

/* ---- I/O accounting suppression ---- */

static int io_account_read_pre(struct kprobe *p, struct pt_regs *regs)
{
	/* task_io_account_read(unsigned long bytes) — single parameter */
	if (is_stealth_io_active())
		PT_REGS_PARM1(regs) = 0;
	return 0;
}

static int io_account_write_pre(struct kprobe *p, struct pt_regs *regs)
{
	/* task_io_account_write(unsigned long bytes) — single parameter */
	if (is_stealth_io_active())
		PT_REGS_PARM1(regs) = 0;
	return 0;
}

static struct kprobe io_account_read_kp = {
	.symbol_name = "task_io_account_read",
	.pre_handler = io_account_read_pre,
};

static struct kprobe io_account_write_kp = {
	.symbol_name = "task_io_account_write",
	.pre_handler = io_account_write_pre,
};

/* ---- File lock source suppression ---- */
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 12, 0)
static int locks_init_lock_pre(struct kprobe *p, struct pt_regs *regs)
{
	struct file_lock *fl = (struct file_lock *)PT_REGS_PARM1(regs);

	if (fl && is_stealth_io_active())
		fl->fl_pid = 0;
	return 0;
}

static struct kprobe locks_init_lock_kp = {
	.symbol_name = "locks_init_lock",
	.pre_handler = locks_init_lock_pre,
};

static int posix_lock_file_pre(struct kprobe *p, struct pt_regs *regs)
{
	struct file_lock *fl = (struct file_lock *)PT_REGS_PARM2(regs);
	if (fl && is_stealth_io_active())
		fl->fl_pid = 0;
	return 0;
}

static int flock_lock_file_pre(struct kprobe *p, struct pt_regs *regs)
{
	struct file_lock *fl = (struct file_lock *)PT_REGS_PARM2(regs);
	if (fl && is_stealth_io_active())
		fl->fl_pid = 0;
	return 0;
}

static int locks_insert_lock_pre(struct kprobe *p, struct pt_regs *regs)
{
	struct file_lock *fl = (struct file_lock *)PT_REGS_PARM1(regs);
	if (fl && is_stealth_io_active())
		fl->fl_pid = 0;
	return 0;
}

static int locks_insert_block_pre(struct kprobe *p, struct pt_regs *regs)
{
	struct file_lock *fl1 = (struct file_lock *)PT_REGS_PARM1(regs);
	struct file_lock *fl2 = (struct file_lock *)PT_REGS_PARM2(regs);
	if (is_stealth_io_active()) {
		if (fl1)
			fl1->fl_pid = 0;
		if (fl2)
			fl2->fl_pid = 0;
	}
	return 0;
}

static int posix_test_lock_pre(struct kprobe *p, struct pt_regs *regs)
{
	struct file_lock *fl = (struct file_lock *)PT_REGS_PARM2(regs);
	if (fl && is_stealth_io_active())
		fl->fl_pid = 0;
	return 0;
}

static int locks_copy_lock_pre(struct kprobe *p, struct pt_regs *regs)
{
	struct file_lock *dst = (struct file_lock *)PT_REGS_PARM1(regs);
	struct file_lock *src = (struct file_lock *)PT_REGS_PARM2(regs);
	if (is_stealth_io_active()) {
		if (dst)
			dst->fl_pid = 0;
		if (src)
			src->fl_pid = 0;
	}
	return 0;
}

static struct kprobe posix_lock_file_kp = {
	.symbol_name = "posix_lock_file",
	.pre_handler = posix_lock_file_pre,
};

static struct kprobe flock_lock_file_kp = {
	.symbol_name = "flock_lock_file",
	.pre_handler = flock_lock_file_pre,
};

static struct kprobe locks_insert_lock_kp = {
	.symbol_name = "locks_insert_lock",
	.pre_handler = locks_insert_lock_pre,
};

static struct kprobe locks_insert_block_kp = {
	.symbol_name = "locks_insert_block",
	.pre_handler = locks_insert_block_pre,
};

static struct kprobe posix_test_lock_kp = {
	.symbol_name = "posix_test_lock",
	.pre_handler = posix_test_lock_pre,
};

static struct kprobe locks_copy_lock_kp = {
	.symbol_name = "locks_copy_lock",
	.pre_handler = locks_copy_lock_pre,
};
#endif /* LINUX_VERSION_CODE < 6.12 */

#endif /* CONFIG_KRETPROBES */

/* ---- /proc/[pid]/io Stats Hiding ---- */

/**
 * ksu_filter_proc_pid_io() - Zero out I/O stats for stealth PIDs.
 *
 * When someone reads /proc/<stealth_pid>/io, replace all counters
 * with zero to hide file I/O activity.
 *
 * Format of /proc/[pid]/io:
 *   rchar: <N>
 *   wchar: <N>
 *   syscr: <N>
 *   syscw: <N>
 *   read_bytes: <N>
 *   write_bytes: <N>
 *   cancelled_write_bytes: <N>
 */
ssize_t ksu_filter_proc_pid_io(char __user *ubuf, ssize_t count)
{
	static const char zeroed_io[] =
		"rchar: 0\n"
		"wchar: 0\n"
		"syscr: 0\n"
		"syscw: 0\n"
		"read_bytes: 0\n"
		"write_bytes: 0\n"
		"cancelled_write_bytes: 0\n";
	ssize_t zeroed_len = sizeof(zeroed_io) - 1;
	ssize_t out_len;
	if (!ksu_should_hide_proc_general())
		return count;

	if (count <= 0)
		return count;

	out_len = min_t(ssize_t, zeroed_len, count);
	if (copy_to_user(ubuf, zeroed_io, out_len))
		return count; /* On error, return original */

	return out_len;
}

/* ---- /proc/locks Filtering ---- */

/**
 * ksu_filter_proc_locks() - Remove stealth PID entries from /proc/locks.
 *
 * /proc/locks format (each line):
 *   <N>: <TYPE> <ADVISORY> <RW> <PID> <MAJ:MIN:INODE> <START> <END>
 *
 * We parse column 5 (PID) from each line and drop lines where
 * the PID is a stealth PID.
 */
ssize_t ksu_filter_proc_locks(char __user *ubuf, ssize_t count)
{
	char *kbuf, *src, *dst, *line_start, *line_end;
	ssize_t new_len = 0;
	if (!ksu_should_hide_proc_general())
		return count;

	if (count <= 0)
		return count;

	kbuf = kmalloc(count + 1, GFP_KERNEL);
	if (!kbuf)
		return count;

	if (copy_from_user(kbuf, ubuf, count)) {
		kfree(kbuf);
		return count;
	}
	kbuf[count] = '\0';

	src = kbuf;
	dst = kbuf;
	line_start = src;

	while (line_start < src + count) {
		char *p;
		int col;
		pid_t pid;
		size_t line_len;
		bool filter_line = false;

		line_end = memchr(line_start, '\n',
				  (src + count) - line_start);
		if (!line_end)
			line_end = src + count;
		else
			line_end++; /* Include newline */

		line_len = line_end - line_start;

		/* Parse PID from column 5 (0-indexed: 4)
		 * Format: "1: POSIX  ADVISORY  WRITE 1234 ..."
		 * Columns are space-separated, but may have
		 * multiple spaces between them.
		 */
		p = line_start;
		col = 0;
		while (p < line_start + line_len && col < 4) {
			/* Skip current token */
			while (p < line_start + line_len &&
			       *p != ' ' && *p != '\n')
				p++;
			/* Skip spaces */
			while (p < line_start + line_len && *p == ' ')
				p++;
			col++;
		}

		if (col == 4 && p < line_start + line_len) {
			pid = 0;
			while (p < line_start + line_len &&
			       *p >= '0' && *p <= '9' &&
			       pid < 10000000) {
				pid = pid * 10 + (*p - '0');
				p++;
			}
			if (pid == 0 || ksu_is_stealth_pid(pid))
				filter_line = true;
		}

		if (!filter_line) {
			if (dst != line_start)
				memmove(dst, line_start, line_len);
			dst += line_len;
			new_len += line_len;
		}

		line_start = line_end;
	}

	if (new_len != count) {
		if (copy_to_user(ubuf, kbuf, new_len)) {
			kfree(kbuf);
			return count;
		}
	}

	kfree(kbuf);
	return new_len;
}

/**
 * ksu_should_filter_fileio() - Check if a path needs stealth fileio filtering.
 * @path: file path being read
 * @out_pid: if non-NULL, receives the parsed PID from /proc/<pid>/io paths
 *
 * Returns: 1 for /proc/<stealth_pid>/io, 2 for /proc/locks, 0 otherwise.
 */
int ksu_should_filter_fileio(const char *path, pid_t *out_pid)
{
	const char *p;
	pid_t pid;

	if (!path)
		return 0;

	/* Check /proc/locks */
	if (strcmp(path, "/proc/locks") == 0)
		return 2;

	/* Check /proc/<pid>/io */
	if (strncmp(path, "/proc/", 6) != 0)
		return 0;

	p = path + 6;
	pid = 0;
	if (!strncmp(p, "self", 4) && (p[4] == '/' || p[4] == '\0')) {
		pid = current->tgid;
		p += 4;
	} else if (!strncmp(p, "thread-self", 11) &&
		   (p[11] == '/' || p[11] == '\0')) {
		pid = current->tgid;
		p += 11;
	} else {
		while (*p >= '0' && *p <= '9' && pid < 10000000) {
			pid = pid * 10 + (*p - '0');
			p++;
		}
	}

	if (pid <= 0 || strcmp(p, "/io") != 0)
		return 0;

	if (!ksu_is_stealth_pid(pid))
		return 0;

	if (out_pid)
		*out_pid = pid;

	return 1;
}

/* ---- Init/Exit ---- */

void ksu_stealth_fileio_init(void)
{
#ifdef CONFIG_KRETPROBES
	int ret;

	/* fsnotify suppression hooks */
	ret = register_kprobe(&fsnotify_kp);
	if (ret)
		pr_err("stealth_fileio: fsnotify hook failed: %d\n", ret);

	ret = register_kprobe(&fsnotify_parent_kp);
	if (ret)
		pr_err("stealth_fileio: fsnotify_parent hook failed: %d\n",
		       ret);

	/* Auto timestamp protection hooks */
	ret = register_kretprobe(&vfs_read_rp);
	if (ret)
		pr_err("stealth_fileio: vfs_read hook failed: %d\n", ret);

	ret = register_kretprobe(&vfs_write_rp);
	if (ret)
		pr_err("stealth_fileio: vfs_write hook failed: %d\n", ret);

	/* I/O accounting suppression */
	ret = register_kprobe(&io_account_read_kp);
	if (ret)
		pr_err("stealth_fileio: io_account_read hook failed: %d\n", ret);
	ret = register_kprobe(&io_account_write_kp);
	if (ret)
		pr_err("stealth_fileio: io_account_write hook failed: %d\n", ret);

	/* File lock source suppression (fl_pid removed in 6.12) */
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 12, 0)
	ret = register_kprobe(&locks_init_lock_kp);
	if (ret)
		pr_err("stealth_fileio: locks_init_lock hook failed: %d\n", ret);
	ret = register_kprobe(&posix_lock_file_kp);
	if (ret)
		pr_err("stealth_fileio: posix_lock_file hook failed: %d\n", ret);
	ret = register_kprobe(&flock_lock_file_kp);
	if (ret)
		pr_err("stealth_fileio: flock_lock_file hook failed: %d\n", ret);
	ret = register_kprobe(&locks_insert_lock_kp);
	if (ret)
		pr_err("stealth_fileio: locks_insert_lock hook failed: %d\n", ret);
	ret = register_kprobe(&locks_insert_block_kp);
	if (ret)
		pr_err("stealth_fileio: locks_insert_block hook failed: %d\n", ret);
	ret = register_kprobe(&posix_test_lock_kp);
	if (ret)
		pr_err("stealth_fileio: posix_test_lock hook failed: %d\n", ret);
	ret = register_kprobe(&locks_copy_lock_kp);
	if (ret)
		pr_err("stealth_fileio: locks_copy_lock hook failed: %d\n", ret);
#endif
#endif
}

void ksu_stealth_fileio_exit(void)
{
#ifdef CONFIG_KRETPROBES
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 12, 0)
	unregister_kprobe(&locks_insert_block_kp);
	unregister_kprobe(&locks_insert_lock_kp);
	unregister_kprobe(&locks_copy_lock_kp);
	unregister_kprobe(&posix_test_lock_kp);
	unregister_kprobe(&flock_lock_file_kp);
	unregister_kprobe(&posix_lock_file_kp);
	unregister_kprobe(&locks_init_lock_kp);
#endif
	unregister_kprobe(&io_account_write_kp);
	unregister_kprobe(&io_account_read_kp);
	unregister_kretprobe(&vfs_write_rp);
	unregister_kretprobe(&vfs_read_rp);
	unregister_kprobe(&fsnotify_parent_kp);
	unregister_kprobe(&fsnotify_kp);
#endif
}
